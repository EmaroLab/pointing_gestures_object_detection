#include <ros/ros.h>
#include <visualization_msgs/Marker.h>
#include <tf/transform_listener.h>
#include <geometry_msgs/Twist.h>
#include <string>
#include <iostream>
#include <math.h>

using namespace std;

void visualize_line(geometry_msgs::Point r_elbow_pose, geometry_msgs::Point r_hand_pose, ros::NodeHandle n);

int main( int argc, char** argv )
{
	ros::init(argc, argv, "tracker_node");
	ros::NodeHandle node;
	//frequency
	ros::Rate r(5);			

	ros::Publisher right_elbow_joint = node.advertise<geometry_msgs::Point>("right_elbow_joint", 1);
	ros::Publisher right_hand_joint = node.advertise<geometry_msgs::Point>("right_hand_joint", 1);
	
	//geometry points declaration for storing 3D coordinates of joints and then published later 
	geometry_msgs::Point right_elbow_pose, right_hand_pose, p0;
	
	// listener 
	tf::TransformListener listener;

	
	
	while (ros::ok())
	{ 
		p0 = right_hand_pose;

		// Transforms declared for each joint
		tf::StampedTransform transform_right_elbow, transform_right_hand;	

		try
		{
			// each joint frame to reference frame transforms. 
			// we use left frame (elbow and hand) because the Kinect detects users mirrored.
			listener.lookupTransform("/camera_link", "/left_elbow_1",ros::Time(0), transform_right_elbow);
			listener.lookupTransform("/camera_link", "/left_hand_1",ros::Time(0), transform_right_hand);
		}
		catch (tf::TransformException &ex)
		{
			ROS_ERROR("%s",ex.what());
			ros::Duration(1.0).sleep();
			continue;
		}

		// joint position extraction and store:
		// right elbow joint
		right_elbow_pose.x = transform_right_elbow.getOrigin().x();
		right_elbow_pose.y = transform_right_elbow.getOrigin().y();
		right_elbow_pose.z = transform_right_elbow.getOrigin().z();
		// right hand joint
		right_hand_pose.x = transform_right_hand.getOrigin().x();
		right_hand_pose.y = transform_right_hand.getOrigin().y();
		right_hand_pose.z = transform_right_hand.getOrigin().z();

		//used to visualize the line on Rviz
		if(right_elbow_pose.x > right_hand_pose.x)
		{
			visualize_line(right_elbow_pose, right_hand_pose, node);
		}

		//publishing of right_elbow_pose e right_hand_pose
		//right_elbow_joint.publish(right_elbow_pose);
		//right_hand_joint.publish(right_hand_pose);
		

		double distance = sqrt( pow((double)p0.x - (double)right_hand_pose.x, 2)+
								pow((double)p0.y - (double)right_hand_pose.y, 2)+
								pow((double)p0.z - (double)right_hand_pose.z, 2));
	
		if(distance<0.005 && right_elbow_pose.x > right_hand_pose.x){
			//publishing of right_elbow_pose e right_hand_pose
			right_elbow_joint.publish(right_elbow_pose);
			right_hand_joint.publish(right_hand_pose);
		}

   		r.sleep();

	}
    r.sleep();

}

void visualize_line(geometry_msgs::Point r_elbow_pose, geometry_msgs::Point r_hand_pose, ros::NodeHandle n)
{
	ros::Publisher marker_pub = n.advertise<visualization_msgs::Marker>("visualization_marker", 1);
	// Set our initial shape type to be a line
  	uint32_t shape = visualization_msgs::Marker::LINE_STRIP;

	//variables used to contain the velues of the x,y,z coordinates of r_elbow and r_hand
	float x1,y1,z1;
	float x2,y2,z2;
 		
	x1 = r_hand_pose.x;
	y1 = r_hand_pose.y;
	z1 = r_hand_pose.z;

	x2 = r_elbow_pose.x;
	y2 = r_elbow_pose.y;
	z2 = r_elbow_pose.z;
	
	//second point used to draw the straight line from the elbow
	geometry_msgs::Point endLinePoint;
	endLinePoint.x= 0.0;
	endLinePoint.y= y1 - ((x1 * (y2 - y1)) / (x2 - x1));
	endLinePoint.z= z1 - ((x1 * (z2 - z1)) / (x2 - x1));
	
	visualization_msgs::Marker marker;

   	// Set the frame ID and timestamp.  See the TF tutorials for information on these.
   	marker.header.frame_id = "/camera_link";
   	marker.header.stamp = ros::Time::now();

	// Set the namespace and id for this marker.  This serves to create a unique ID
    // Any marker sent with the same namespace and id will overwrite the old one
    marker.ns = "line_strip";
    marker.id = 0;
	
    // Set the marker type
    marker.type = shape;
	
    // Set the marker action.  Options are ADD, DELETE, and new in ROS Indigo: 3 (DELETEALL)
    marker.action = visualization_msgs::Marker::ADD;
	
    // Set the scale of the marker
    marker.scale.x = 0.01;
	
	// Set the two points for the line. It starts from elbow and finish to endLinePoint
	marker.points.push_back(r_elbow_pose);
	marker.points.push_back(endLinePoint);
	
    // Set the color -- be sure to set alpha(transparency) to something non-zero! (RGB 1.0/1.0/1.0 --> white)
    marker.color.r = 1.0f;
    marker.color.g = 1.0f;
    marker.color.b = 1.0f;
    marker.color.a = 1.0;
	
    marker.lifetime = ros::Duration();

    // Publish the marker
    marker_pub.publish(marker);
}


